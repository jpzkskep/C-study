/*
int arr[2][3] = { {1,2,3}, {4,5,6} }; 라는 2차원 배열이 있을 때,

아래 각각의 표현식이 어떤 값을 가리키는지 직접 출력해보며 비교하라:
arr[1][2]
*(arr[1] + 2)
*(*(arr + 1) + 2)
*(&arr[1][0] + 2)
*(*(arr + 0) + 4)
각 표현식에서 어떤 주소로부터 몇 칸 이동하는지를 정확히 주석으로 설명하라.

조건:
[] 연산자와 * 연산자를 혼합한 다양한 인덱싱 방식 비교
arr + n, arr[n], *(arr + n) 등을 모두 실험
2차원 배열의 주소 계산 방식과 1차원처럼 처리되는 구조를 정확히 이해할 것
*/
#include <stdio.h>
int main() {
	int arr[2][3] = { {1,2,3},{4,5,6} };
	printf("arr[1][2] = %d \n", arr[1][2]);
	// arr[1][2]는 6 arr[0][n]은 1시작 arr[1][n]은 4시작
	printf("*(arr[1]+2) = %d \n", *(arr[1] + 2));
	// *(arr[1]+2)는 arr[1][2]와 같음 *(arr[0]+1)은 2임
	printf("*(*(arr+1)+2) = %d \n", *(*(arr + 1) + 2));
	// *(*(arr+1)+2)는 arr[1][2]와 같음 *(*(arr+0)+2)는 arr[0][2]임
	printf("*(&arr[1][0]+2) = %d \n", *(&arr[1][0] + 2));
	// *(&arr[1][0]+2)는 
	printf("*(*(arr+0)+4) = %d \n", *(*(arr + 0) + 4));
	// *(*(arr+0)+4)는 arr[1][1]과 같음
	return 0;
}